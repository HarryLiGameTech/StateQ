
#ifndef QIVMBE_SIMULATOR_INSTRUCTION_HPP
#define QIVMBE_SIMULATOR_INSTRUCTION_HPP

#include "QuEST.h"
#include "exception.hpp"

#include <cstdint>
#include <utility>
#include <vector>
#include <variant>

using QubitAddr = std::uint32_t;

struct PrimitiveInstruction;
class StandardGateInstruction;

using Instruction = std::variant<PrimitiveInstruction, StandardGateInstruction>;

union InstructionParam
{
    double float64;
    std::int64_t int64;
    std::uint64_t uint64;
};

enum struct PrimitiveOpCode : std::uint8_t
{
    Alloc = 0x00,
    Reset = 0x01,
    Measure = 0x02,
};

struct PrimitiveInstruction
{
    PrimitiveOpCode opcode;
    std::vector<InstructionParam> params;

    explicit inline PrimitiveInstruction(
        PrimitiveOpCode opcode, std::vector<InstructionParam> param
    ) : opcode(opcode), params(std::move(param)) {}

    [[nodiscard]]
    inline std::string toString() const
    {
        std::string result;
        switch (opcode) {
            case PrimitiveOpCode::Alloc:
                result += "Alloc";
                break;
            case PrimitiveOpCode::Reset:
                result += "Reset";
                break;
            case PrimitiveOpCode::Measure:
                result += "Measure";
                break;
        }
        result += "(";
        for (const auto & param: params) {
            result += std::to_string(param.uint64) + ", ";
        }
        result += ")";
        return result;
    }
};

enum struct StandardGate : std::uint8_t
{
    /*
    # generated by the following python code
    gates = [
        'I', 'H', 'X', 'Y', 'Z', 'XPOW', 'YPOW', 'ZPOW', 'S', 'SD',
        'T', 'TD', 'V', 'VD', 'P', 'RX', 'RY', 'RZ', 'RN', 'U',
        'CX', 'CY', 'CZ', 'CH', 'CP', 'SWP', 'SSWP', 'SSWPD',
        'ISWP', 'ISWPD', 'SISWP', 'SISWPD', 'CAN', 'CCX', 'CSWP'
    ]
    for i, gate in enumerate(gates):
        print(f'{gate:7} = 0x{hex(i)[2:]:>02},')
    */
    I       = 0x00,
    H       = 0x01,
    X       = 0x02,
    Y       = 0x03,
    Z       = 0x04,
    XPOW    = 0x05,
    YPOW    = 0x06,
    ZPOW    = 0x07,
    S       = 0x08,
    SD      = 0x09,
    T       = 0x0a,
    TD      = 0x0b,
    V       = 0x0c,
    VD      = 0x0d,
    P       = 0x0e,
    RX      = 0x0f,
    RY      = 0x10,
    RZ      = 0x11,
    RN      = 0x12,
    U       = 0x13,
    CX      = 0x14,
    CY      = 0x15,
    CZ      = 0x16,
    CH      = 0x17,
    CP      = 0x18,
    SWP     = 0x19,
    SSWP    = 0x1a,
    SSWPD   = 0x1b,
    ISWP    = 0x1c,
    ISWPD   = 0x1d,
    SISWP   = 0x1e,
    SISWPD  = 0x1f,
    CAN     = 0x20,
    CCX     = 0x21,
    CSWP    = 0x22,
};

inline std::string gateToString(const StandardGate& gate)
{
    /*
    # generated by the following python code
    gates = [
        'I', 'H', 'X', 'Y', 'Z', 'XPOW', 'YPOW', 'ZPOW', 'S', 'SD',
        'T', 'TD', 'V', 'VD', 'P', 'RX', 'RY', 'RZ', 'RN', 'U',
        'CX', 'CY', 'CZ', 'CH', 'CP', 'SWP', 'SSWP', 'SSWPD',
        'ISWP', 'ISWPD', 'SISWP', 'SISWPD', 'CAN', 'CCX', 'CSWP'
    ]
    print('switch (gate) {')
    for i, gate in enumerate(gates):
        print(f'    case StandardGate::{gate + ":":8} return "{gate}";')
    print('}')
    */
    switch (gate)
    {
        case StandardGate::I:       return "I";
        case StandardGate::H:       return "H";
        case StandardGate::X:       return "X";
        case StandardGate::Y:       return "Y";
        case StandardGate::Z:       return "Z";
        case StandardGate::XPOW:    return "XPOW";
        case StandardGate::YPOW:    return "YPOW";
        case StandardGate::ZPOW:    return "ZPOW";
        case StandardGate::S:       return "S";
        case StandardGate::SD:      return "SD";
        case StandardGate::T:       return "T";
        case StandardGate::TD:      return "TD";
        case StandardGate::V:       return "V";
        case StandardGate::VD:      return "VD";
        case StandardGate::P:       return "P";
        case StandardGate::RX:      return "RX";
        case StandardGate::RY:      return "RY";
        case StandardGate::RZ:      return "RZ";
        case StandardGate::RN:      return "RN";
        case StandardGate::U:       return "U";
        case StandardGate::CX:      return "CX";
        case StandardGate::CY:      return "CY";
        case StandardGate::CZ:      return "CZ";
        case StandardGate::CH:      return "CH";
        case StandardGate::CP:      return "CP";
        case StandardGate::SWP:     return "SWP";
        case StandardGate::SSWP:    return "SSWP";
        case StandardGate::SSWPD:   return "SSWPD";
        case StandardGate::ISWP:    return "ISWP";
        case StandardGate::ISWPD:   return "ISWPD";
        case StandardGate::SISWP:   return "SISWP";
        case StandardGate::SISWPD:  return "SISWPD";
        case StandardGate::CAN:     return "CAN";
        case StandardGate::CCX:     return "CCX";
        case StandardGate::CSWP:    return "CSWP";
    }
    return "unreachable";
}

class StandardGateInstruction
{
  private:

    StandardGate gate;
    std::vector<InstructionParam> params;
    std::vector<QubitAddr> targets;

  public:

    explicit inline StandardGateInstruction(
        StandardGate gate,
        const std::vector<InstructionParam> & params,
        const std::vector<QubitAddr> & targets
    ) : gate(gate), params(params), targets(targets) {}

    void execute(Qureg* qureg) const;

    [[nodiscard]]
    inline std::string toString() const
    {
        std::string paramsString = "(";
        for (const auto& param: params) {
            paramsString += std::to_string(param.float64);
        }
        paramsString += ") ";
        std::string targetsString;
        for (const auto& target: targets) {
            targetsString += std::to_string(target) + " ";
        }
        return gateToString(gate) + (params.empty() ? " " : paramsString) + targetsString;
    }

    [[nodiscard]]
    inline std::string gateIdent() const
    {
        return gateToString(gate);
    }

    inline void assertNumParamsAndTargetSize(size_t expectedNumParams, size_t expectedTargetSize) const
    {
        if (this->params.size() != expectedNumParams) {
            throw MissingOrExtraParameterException(gateIdent(), expectedNumParams, params.size());
        }
        if (this->targets.size() != expectedTargetSize) {
            throw TargetSizeNotMatchException(gateIdent(), expectedTargetSize, targets.size());
        }
    }
};

#endif // QIVMBE_SIMULATOR_INSTRUCTION_HPP
